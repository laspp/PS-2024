// Code generated by cudago. Edit at your own risk.
package cudago

import (
    "github.com/InternatBlackhole/cudago/cuda"
	"github.com/InternatBlackhole/cudago/nvrtc"
	"errors"
	"bufio"
	"os"
	"fmt"
)

var (
	errLibNotInit = errors.New("library not initialized")
)

var LoadedLibs = make(map[string]*cuda.Library)

var kernCache = make(map[string]map[string]*cuda.Kernel) //cache for the kernels: RawName -> CudaKernel

func InitLibrary(code []byte, name string) error {
	lib := LoadedLibs[name]
	if lib == nil {
		//load the kernel from PTX/cubin code and init kernel cache
		kernCache[name] = make(map[string]*cuda.Kernel)
		var err error
		lib, err = cuda.LoadLibraryData(code, nil, nil)
		if err != nil {
			return err
		}
		LoadedLibs[name] = lib
	}
	return nil
}

func CloseLibrary(name string) error {
	lib := LoadedLibs[name]
	if lib == nil {
		return errLibNotInit
	}
	delete(LoadedLibs, name)
	delete(kernCache, name)
	return lib.Unload()
}

func getKernel(libName, kernelName string) (*cuda.Kernel, error) {
	var err error
	lib := LoadedLibs[libName]
	if lib == nil {
		return nil, errLibNotInit
	}
	kern := kernCache[libName][kernelName]
	if kern == nil {
		kern, err = lib.GetKernel(kernelName)
		if err != nil {
			return nil, err
		}
		kernCache[libName][kernelName] = kern
	}
	return kern, nil
}

func compileFile(path string) ([]byte, error) {
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	stat, err := file.Stat()
	if err != nil {
		return nil, err
	}
	buf := make([]byte, stat.Size())
	reader := bufio.NewReader(file)
	read, err := reader.Read(buf)
	if err != nil {
		return nil, err
	}
	if read != len(buf) {
		return nil, errors.New("could not read the whole file")
	}
	program, err := nvrtc.CreateProgram(string(buf), file.Name(), nil)
	if err != nil {
		return nil, nvrtcErr(err, program)
	}
	defer program.Destroy()
	err = program.Compile([]string{  })
	if err != nil {
		return nil, nvrtcErr(err, program)
	}

	ptx, err := program.GetPTX()
	if err != nil {
		return nil,	nvrtcErr(err, program)
	}
	return ptx, nil
}

func nvrtcErr(orig error, program *nvrtc.Program) error {
	log, err := program.GetLog()
	if err != nil {
		return err
	}
	return fmt.Errorf("error \"%s\" log: %s", orig, log)
}
